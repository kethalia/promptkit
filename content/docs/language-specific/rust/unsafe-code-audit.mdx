---
title: "Unsafe Code Audit"
description: "Systematically audit all unsafe blocks for soundness, invariants, and potential undefined behavior."
---

# Unsafe Code Audit

Systematically audit all unsafe blocks for soundness, invariants, and potential undefined behavior.

---

## Context

Gather before starting:
- All Rust source files containing `unsafe` keyword
- Any FFI bindings or C interop code
- Documentation for external libraries being interfaced with
- The project's safety documentation or SAFETY comments
- Miri configuration if available for testing

## Instructions

1. **Inventory all unsafe blocks in codebase**
   - Search for `unsafe fn`, `unsafe impl`, `unsafe trait`, and `unsafe {}` blocks
   - Catalog each occurrence with file, line, and surrounding context
   - Note the reason for unsafe (raw pointers, FFI, intrinsics, etc.)
   - Identify unsafe code without safety documentation

2. **Document the invariants each unsafe block relies on**
   - For each unsafe block, identify what must be true for soundness
   - Check that invariants are documented in SAFETY comments
   - Verify callers maintain these invariants
   - Identify invariants that could be enforced by types instead

3. **Check for undefined behavior risks**
   - Check for null pointer dereferences
   - Verify pointer alignment requirements
   - Check for data races in concurrent unsafe code
   - Verify slice bounds are valid
   - Check for use-after-free potential
   - Verify transmute type compatibility
   - Check for uninitialized memory reads

4. **Validate pointer operations**
   - Verify pointer arithmetic stays within bounds
   - Check offset calculations for overflow
   - Validate pointer provenance is maintained
   - Ensure pointers are not used after their backing allocation is freed
   - Check for aliasing violations

5. **Review FFI boundaries**
   - Verify C function signatures match exactly
   - Check that nullable pointers use `Option<NonNull<T>>`
   - Verify string handling (null termination, encoding)
   - Check callback safety and panic handling
   - Review memory ownership at FFI boundaries
   - Verify error handling across language boundaries

6. **Check for memory safety guarantees**
   - Verify all raw pointer dereferences are valid
   - Check that mutable aliasing rules are followed
   - Validate that memory is properly initialized before use
   - Ensure proper drop handling for unsafe code paths
   - Check for memory leaks in error paths

7. **Propose safe alternatives where possible**
   - For each unsafe block, research if a safe alternative exists
   - Check if newer Rust versions provide safe APIs
   - Look for crates that safely abstract the unsafe operation
   - Consider if the unsafe is necessary or just an optimization

8. **Prioritize by risk level**
   - Critical: UB possible with valid inputs
   - High: UB possible with edge case inputs
   - Medium: Relies on undocumented invariants
   - Low: Well-documented, minimal attack surface

## Output Format

```markdown
## Unsafe Code Audit Report

### Summary
- Total unsafe blocks: N
- Total unsafe functions: N
- Total unsafe trait impls: N
- Issues found: N (critical: X, high: Y, medium: Z, low: W)

### Critical Issues (Fix Immediately)
| Location | Issue | UB Risk | Remediation |
|----------|-------|---------|-------------|
| file:line | description | type | fix |

### High Priority Issues
| Location | Issue | Risk | Remediation |
|----------|-------|------|-------------|
| file:line | description | type | fix |

### Unsafe Block Inventory

#### Block 1: `path/file.rs:42`
```rust
// Code snippet
```
- **Purpose**: Why unsafe is used
- **Risk Level**: Critical/High/Medium/Low
- **Invariants Required**:
  - Pointer must be non-null
  - Pointer must be aligned to N bytes
  - Referenced memory must be initialized
- **Current Safety Documentation**: Present/Missing/Incomplete
- **Soundness**: Sound/Unsound/Conditional
- **Safe Alternative**: Available/None/Partial

### FFI Boundary Review
| Function | Signature Match | Null Handling | Memory Ownership |
|----------|-----------------|---------------|------------------|
| extern_fn | ✓/✗ | Correct/Missing | Clear/Ambiguous |

### Missing Safety Documentation
- `file.rs:100` - No SAFETY comment
- `file.rs:200` - Incomplete documentation

### Recommended SAFETY Comments
```rust
// SAFETY: `ptr` is guaranteed non-null by the check on line 40.
// The memory is valid for reads of `len` bytes as ensured by
// the allocation on line 35.
```

### Safe Alternatives Available
| Location | Current Unsafe | Safe Alternative | Trade-off |
|----------|---------------|------------------|-----------|
| file:line | raw pointer | slice::from_raw_parts | none |
```

## Interactive Decisions

Pause for user input on:
- **Unclear invariants**: When the required invariants aren't obvious from context
- **Soundness uncertainty**: When soundness depends on external factors or domain knowledge
- **Safe alternative trade-offs**: When a safe alternative exists but has performance cost
- **FFI signature ambiguity**: When C headers are unavailable or ambiguous
- **Breaking changes**: When fixing unsoundness requires API changes
- **Third-party unsafe**: When unsafe comes from dependencies - discuss upstream reporting
